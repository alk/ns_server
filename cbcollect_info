#!/usr/bin/python
# -*- python -*-
import os
import sys
import tempfile
import time
import subprocess
import string
import re
import platform
import glob

USAGE = """usage: %prog [options] output_file.zip

- Linux/Windows/OSX:
    %prog output_file.zip
    %prog -v output_file.zip"""

class TempFile(object):
    unlink = os.unlink
    def __init__(self):
        fd, self.name = tempfile.mkstemp(text=True)
        self.fp = os.fdopen(fd, 'w+')

    def __getattr__(self, name):
        return getattr(self.__dict__['fp'], name)

    def __del__(self):
        try:
            self.fp.close()
        except:
            pass

        self.unlink(self.name)


class Task(object):
    privileged = False
    no_header = False
    num_samples = 0
    interval = 0
    def __init__(self, description, command, **kwargs):
        self.description = description
        self.command = command
        self.__dict__.update(kwargs)

    def execute(self, fp):
        """Run the task"""
        import subprocess
        use_shell = not isinstance(self.command, list)
        if "literal" in self.__dict__:
            print >> fp, self.literal
            return 0

        if hasattr(self, 'reformat') and self.reformat:
            p = subprocess.Popen(self.command, stdout=subprocess.PIPE,
                                 stderr=subprocess.PIPE, shell = use_shell)
            print >> fp, p.stdout.read()
        else:
            env = None
            if "addenv" in self.__dict__:
                env = os.environ.copy()
                env.update(self.addenv)
            p = subprocess.Popen(self.command, bufsize=-1, stdout=fp, stderr=fp,
                                 shell = use_shell, env = env)
        return p.wait()

    def will_run(self):
        """Determine if this task will run on this platform."""
        return sys.platform in self.platforms


class TaskRunner(object):
    default_name = "couchbase.log"

    def __init__(self, verbosity=0):
        self.files = {}
        self.tasks = {}
        self.verbosity = verbosity
        self.start_time = time.strftime("%Y%m%d-%H%M%S", time.gmtime())

    def get_file(self, filename):
        if filename in self.files:
            fp = self.files[filename]
        else:
            fp = TempFile()
            self.files[filename] = fp

        return fp

    def header(self, fp, title, subtitle):
        separator = '=' * 78
        print >> fp, separator
        print >> fp, title
        print >> fp, subtitle
        print >> fp, separator
        fp.flush()

    def log_result(self, result):
        if result == 0:
            print >> sys.stderr, "OK"
        else:
            print >> sys.stderr, "Exit code %d" % result

    def run(self, task):
        """Run a task with a file descriptor corresponding to its log file"""
        if task.will_run():
            print >> sys.stderr, "%s (%s) - " % (task.description, task.command),
            if task.privileged and os.getuid() != 0:
                print >> sys.stderr, "skipped (needs root privs)"
                return

            if hasattr(task, 'log_file'):
                filename = task.log_file
            else:
                filename = self.default_name

            fp = self.get_file(filename)
            if not task.no_header:
                self.header(fp, task.description, task.command)
            result = task.execute(fp)
            fp.flush()
            self.log_result(result)
            for i in xrange(2, task.num_samples + 2):
                print >> sys.stderr, "Taking sample %d after %f seconds - " % \
                    (i, task.interval)
                time.sleep(task.interval)
                result = task.execute(fp)
                self.log_result(result)
        elif self.verbosity >= 2:
            print >> sys.stderr, 'Skipping "%s" (%s): not for platform %s' \
                % (task.description, task.command, sys.platform)

    def zip(self, filename, node):
        """Write all our logs to a zipfile"""
        from zipfile import ZipFile, ZIP_DEFLATED
        zf = ZipFile(filename, mode='w', compression=ZIP_DEFLATED)
        try:
            for name, fp in self.files.iteritems():
                fp.close()
                zf.write(fp.name,
                         "cbcollect_info_%s_%s/%s" % (node, self.start_time, name))
        finally:
            zf.close()

class SolarisTask(Task):
    platforms = ['sunos5', 'solaris']


class LinuxTask(Task):
    platforms = ['linux2']


class WindowsTask(Task):
    platforms = ['win32', 'cygwin']


class MacOSXTask(Task):
    platforms = ['darwin']


class UnixTask(SolarisTask, LinuxTask, MacOSXTask):
    platforms = SolarisTask.platforms + LinuxTask.platforms + MacOSXTask.platforms


class AllOsTask(UnixTask, WindowsTask):
    platforms = UnixTask.platforms + WindowsTask.platforms

def basedir():
    mydir = os.path.dirname(sys.argv[0])
    if mydir == "":
        mydir = "."
    return mydir

def make_os_tasks():
    _tasks = [
        UnixTask("uname", "uname -a"),
        WindowsTask("System information", "systeminfo"),
        WindowsTask("Computer system", "wmic computersystem", reformat=True),
        WindowsTask("Computer OS", "wmic os", reformat=True),
        UnixTask("Directory structure membase - previous versions",
                 "ls -lR /opt/membase /var/membase /var/opt/membase /etc/opt/membase"),
        SolarisTask("Process list snapshot", "prstat -a -c -n 100 -t -v -L 1 10"),
        SolarisTask("Process list", "ps -ef"),
        SolarisTask("Service configuration", "svcs -a"),
        SolarisTask("Swap configuration", "swap -l"),
        SolarisTask("Disk activity", "zpool iostat 1 10"),
        SolarisTask("Disk activity", "iostat -E 1 10"),
        LinuxTask("Process list snapshot", "export TERM=''; top -Hb -n1 || top -H n1"),
        LinuxTask("Process list ", "ps -AwwL -o user,pid,lwp,ppid,nlwp,pcpu,maj_flt,min_flt,pri,nice,vsize,rss,tty,stat,wchan:12,start,bsdtime,command"),
        LinuxTask("Raw /proc/vmstat", "cat /proc/vmstat"),
        LinuxTask("Raw /proc/mounts", "cat /proc/mounts"),
        LinuxTask("Raw /proc/partitions", "cat /proc/partitions"),
        LinuxTask("Raw /proc/diskstats", "cat /proc/diskstats"),
        LinuxTask("Raw /proc/interrupts", "cat /proc/interrupts"),
        LinuxTask("Swap configuration", "free -t"),
        LinuxTask("Swap configuration", "swapon -s"),
        LinuxTask("Kernel modules", "lsmod"),
        LinuxTask("Distro version", "cat /etc/redhat-release"),
        LinuxTask("Distro version", "lsb_release -a"),
        LinuxTask("Installed software", "rpm -qa"),
        # NOTE: AFAIK columns _was_ necessary, but it doesn't appear to be
        # required anymore. I.e. dpkg -l correctly detects stdout as not a
        # tty and stops playing smart on formatting. Lets keep it for few
        # years and then drop, however.
        LinuxTask("Installed software", "COLUMNS=300 dpkg -l"),
        LinuxTask("Extended iostat", "iostat -x -p ALL 1 10 || iostat -x 1 10"),
        LinuxTask("Core dump settings", "find /proc/sys/kernel -type f -name '*core*' -print -exec cat '{}' ';'"),
        UnixTask("sysctl settings", "sysctl -a"),
        LinuxTask("netstat -nap", "netstat -nap"),
        LinuxTask("relevant lsof output", "lsof -n | grep 'moxi\|memcached\|vbucketmigrator\|beam\|couch_compact\|godu\|portsigar'"),
        MacOSXTask("Process list snapshot", "top -l 1"),
        MacOSXTask("Disk activity", "iostat 1 10"),
        MacOSXTask("Process list ",
                   "ps -Aww -o user,pid,lwp,ppid,nlwp,pcpu,pri,nice,vsize,rss,tty,"
                   "stat,wchan:12,start,bsdtime,command"),
        WindowsTask("Service list", "wmic service where state=\"running\" GET caption, name, state", reformat=True),
        WindowsTask("Process list", "wmic process", reformat=True),
        WindowsTask("Process usage", "tasklist /V /fo list", reformat=True),
        WindowsTask("Swap settings", "wmic pagefile", reformat=True),
        WindowsTask("Disk partition", "wmic partition", reformat=True),
        WindowsTask("Disk volumes", "wmic volume", reformat=True),
        UnixTask("Network configuration", "ifconfig -a", interval=10,
                 num_samples=1),
        LinuxTask("Network configuration", "echo link addr neigh rule route netns | xargs -n1 -- sh -x -c 'ip $1 list' --"),
        WindowsTask("Network configuration", "ipconfig /all", interval=10,
                    num_samples=1),
        UnixTask("Network status", "netstat -an"),
        WindowsTask("Network status", "netstat -an"),
        AllOsTask("Network routing table", "netstat -rn"),
        UnixTask("Arp cache", "arp -na"),
        WindowsTask("Arp cache", "arp -a"),
        WindowsTask("Network Interface Controller", "wmic nic", reformat=True),
        WindowsTask("Network Adapter", "wmic nicconfig", reformat=True),
        WindowsTask("Active network connection", "wmic netuse", reformat=True),
        WindowsTask("Protocols", "wmic netprotocol", reformat=True),
        WindowsTask("Cache memory", "wmic memcache", reformat=True),
        WindowsTask("Physical memory", "wmic memphysical", reformat=True),
        WindowsTask("Physical memory chip info", "wmic memorychip", reformat=True),
        WindowsTask("Local storage devices", "wmic logicaldisk", reformat=True),
        UnixTask("Filesystem", "df -ha"),
        UnixTask("System activity reporter", "sar 1 10"),
        UnixTask("System paging activity", "vmstat 1 10"),
        UnixTask("System uptime", "uptime"),
        UnixTask("couchbase user definition", "getent passwd couchbase"),
        UnixTask("couchbase user limits", "su couchbase -c \"ulimit -a\"",
                 privileged=True),
        UnixTask("membase user definition", "getent passwd membase"),
        UnixTask("couchbase user limits", "su couchbase -c \"ulimit -a\"",
                 privileged=True),
        UnixTask("membase user limits", "su membase -c \"ulimit -a\"",
                 privileged=True),
        UnixTask("Interrupt status", "intrstat 1 10"),
        UnixTask("Processor status", "mpstat 1 10"),
        UnixTask("System log", "cat /var/adm/messages"),
        LinuxTask("System log", "cat /var/log/syslog"),
        LinuxTask("System log", "cat /var/log/messages"),
        LinuxTask("All logs", "tar cz /var/log/syslog* /var/log/dmesg /var/log/messages* /var/log/daemon* /var/log/debug* /var/log/kern.log* 2>/dev/null",
                  log_file="syslog.tar.gz", no_header = True),
        LinuxTask("Relevant proc data", "(pgrep moxi; pgrep beam.smp; pgrep memcached; pgrep couch_compact; pgrep portsigar ; pgrep godu) | xargs -n1 -- sh -c 'echo $1; cat /proc/$1/status; cat /proc/$1/limits; cat /proc/$1/smaps; cat /proc/$1/numa_maps; echo' --"),
        LinuxTask("NUMA data", "numactl --hardware"),
        LinuxTask("NUMA data", "numactl --show"),
        LinuxTask("NUMA data", "cat /sys/devices/system/node/node*/numastat"),
        UnixTask("Kernel log buffer", "dmesg"),
        ]

    return _tasks

# stolen from http://rightfootin.blogspot.com/2006/09/more-on-python-flatten.html
def iter_flatten(iterable):
    it = iter(iterable)
    for e in it:
        if isinstance(e, (list, tuple)):
            for f in iter_flatten(e):
                yield f
        else:
            yield e

def flatten(iterable):
    return [e for e in iter_flatten(iterable)]

def read_guts(guts, key):
    if not (key in guts):
        return ""
    return guts[key]

def make_product_task(guts, initargs_path):
    root = os.path.abspath(os.path.join(initargs_path, "..", ".."))
    dbdir = read_guts(guts, "db_dir")
    _tasks = [
        UnixTask("Directory structure",
                 ["ls", "-lR", root, "/opt/membase", "/var/membase", "/etc/opt/membase"]),
        UnixTask("Database directory structure",
                 ["ls", "-lR", dbdir]),
        WindowsTask("Database directory structure",
                    ["dir", "/s", dbdir.replace("/", "\\")]),
        UnixTask("Directory structure membase - previous versions",
                 "ls -lR /opt/membase /var/membase /var/opt/membase /etc/opt/membase"),
        WindowsTask("Version file",
                    "type " + basedir() + "\\..\\VERSION.txt", reformat=True),
        WindowsTask("Manifest file",
                    "type " + basedir() + "\\..\\manifest.txt", reformat=True),
        WindowsTask("Manifest file",
                    "type " + basedir() + "\\..\\manifest.xml", reformat=True),
        LinuxTask("Version file", "cat '%s/VERSION.txt'" % root),
        LinuxTask("Manifest file", "cat '%s/manifest.txt'" % root),
        LinuxTask("Manifest file", "cat '%s/manifest.xml'" % root),
        AllOsTask("Couchbase config", "", literal = read_guts(guts, "ns_config"),
        # TODO: just gather those in python
        WindowsTask("Memcached logs",
                    "cd \"" + read_guts(guts, "memcached_logs_path") + "\" && " +
                    "for /f %a IN ('dir /od /b memcached.log.*') do type %a",
                    log_file="memcached.log", reformat=True),
        LinuxTask("Memcached logs",
                  ["sh", "-c", 'cd "$1"; for file in $(ls -tr memcached.log.*); do cat \"$file\"; done', "--", read_guts(guts, "memcached_logs_path")],
                  log_file="memcached.log"),
        WindowsTask("Ini files",
                    ' ; '.join(["type " + p for p in read_guts(guts, "couch_inis").split(";")]),
                    log_file="ini.log", reformat=True),
        UnixTask("Ini files",
                 ["sh", "-c", 'for i in "$@"; do echo "file: $i"; cat "$i"; done', "--"] + read_guts(guts, "couch_inis").split(";"),
                 log_file="ini.log"),

        [AllOsTask("couchbase logs (%s)" % name, "cbbrowse_logs",
                   addenv = [("REPORT_DIR", read_guts(guts, "log_path"))],
                   log_file="ns_server.%s.log" % name)
         for name in ["debug", "info", "error", "couchdb",
                      "xdcr", "xdcr_errors",
                      "views", "mapreduce_errors",
                      "stats", "babysitter"]],

        [AllOsTask("memcached stats %s" % kind,
                   flatten(["cbstats", "-a", "127.0.0.1:%s" % read_guts(guts, "memcached_port"), kind, "-b", read_guts(guts, "memcached_admin"), "-p", read_guts(guts, "memcached_pass")]),
                   log_file="stats.log")
         for kind in ["all", "checkpoint", "config", "dispatcher",
                      "hash", "klog", "kvstore", "kvtimings",
                      "tap", "tapagg", "timings",
                      ["raw", "memory"], ["raw", "allocator"],
                      "prev-vbucket", "vbucket", "vbucket-details",
                      "warmup"]],

        AllOsTask("couchbase diags",
                  ["curl", "-sS",
                   "-u", '%s:%s' % (read_guts(guts, "rest_user"), read_guts(guts, "rest_pass")),
                   "http://127.0.0.1:%s/diag?noLogs=1" % guts["rest_port"]],
                  log_file="diag.log")]

    _tasks = flatten(_tasks)

    try:
        for f in os.listdir(dbdir):
            path = os.path.join(dbdir, f)
            #find bucket directory
            if os.path.isdir(path) and f not in [".delete", "@indexes"]:
                files = glob.glob("%s/master.couch.[0-9]*" % path)
        if files:
            ddoc = sorted(files, key=lambda x: int(x.split(".")[-1]))[-1]
            _tasks.append(
                AllOsTask("couchbase design docs - bucket:%s" % f,
                          "couch_dbdump \"%s\"" % (os.path.join(path, ddoc)),
                          log_file="ddocs.log"))
    except:
        pass
    return _tasks


def get_server_guts(initargs_path):
    dump_guts_path = os.path.join(basedir(), "..", "lib", "ns_server", "dump-guts")
    escript = "escript"
    if platform.system() == 'Windows':
        escript = escript + ".exe"
    extra_args = os.getenv("EXTRA_DUMP_GUTS_ARGS")
    args = [escript, dump_guts_path, "--initargs-path", initargs_path]
    if extra_args:
        args = args + extra_args.split(";")
    print("Checking for server guts in %s..." % initargs_path)
    p = subprocess.Popen(args, stdout = subprocess.PIPE)
    output = p.stdout.read()
    p.wait()
    rc = p.returncode
    # print("args: %s gave rc: %d and:\n\n%s\n" % (args, rc, output))
    tokens = output.rstrip("\0").split("\0")
    d = {}
    if len(tokens) > 1:
        for i in xrange(0, len(tokens), 2):
            d[tokens[i]] = tokens[i+1]
    return d


def main():
    from optparse import OptionParser
    parser = OptionParser(usage=USAGE)
    parser.add_option("-r", dest="root",
                      help="root directory - defaults to /opt/couchbase",
                      default="/opt/couchbase")
    parser.add_option("-v", dest="verbosity", help="increase verbosity level",
                      action="count", default=0)
    options, args = parser.parse_args()

    if len(args) != 1:
        parser.error("incorrect number of arguments")

    mydir = os.path.dirname(sys.argv[0])
    erldir = os.path.join(mydir, 'erlang', 'bin')
    if os.name == 'posix':
        path = [mydir,
                '/bin',
                '/sbin',
                '/usr/bin',
                '/usr/sbin',
                '/opt/couchbase/bin',
                erldir,
                os.environ['PATH']]
        os.environ['PATH'] = ':'.join(path)
    elif os.name == 'nt':
      path = [mydir, erldir, os.environ['PATH']]
      os.environ['PATH'] = ';'.join(path)

    runner = TaskRunner(verbosity=options.verbosity)

    for task in make_os_tasks():
      runner.run(task)

    initargs_variants = [os.path.abspath(os.path.join(mydir, "..", "var", "lib", "couchbase", "initargs")),
                         os.path.abspath(options.root + "/var/lib/couchbase/initargs"),
                         os.path.expanduser("~/Library/Application Support/Couchbase/var/lib/couchbase/initargs")]

    longest_guts = None
    longest_guts_initargs_path = None

    for initargs_path in initargs_variants:
        d = get_server_guts(initargs_path)
        # print("for initargs: %s got:\n%s" % (initargs_path, d))
        if len(d) > 0 and ((longest_guts == None) or len(longest_guts) < len(d)):
            longest_guts = d
            longest_guts_initargs_path = initargs_path

    if longest_guts:
        runner.run(
            AllOsTask("product diag header",
                      "",
                      literal = "Found server initargs at %s (%d)" % (longest_guts_initargs_path, len(longest_guts))))

        for task in make_product_task(longest_guts, longest_guts_initargs_path):
            runner.run(task)

    runner.zip(args[0], 'TODO')


if __name__ == '__main__':
    main()
